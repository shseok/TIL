- 유닉스
    - 파일 시스템으로 구성되어 있고 트리구조로 되어있다
- Shell
    - OS를 쓸 때, 사용자와 인터페이스하는데 이어져있다. (OS Level의 바깥층)
    - shell 명령어를 통해 커널과 컴퓨터 시스템을 사용할 수 있다
    - 기본적으로 터미널 인터페이스를 사용한다
    - ex) ssh로 로그인 -> ssh서버가 로그인 프로그램(서비스) 실행 -> 로그인 후 서버의 터미널이 shell 실행
    - Shell(BASH)을 쓰기 위한 최소한의 지식
        - https://devhints.io/bash
    - Shell(BASH)을 깊이 있게 사용하기 위한 링크
        - https://github.com/mug896/bash-shell


- 명령어

    (중간)
    - ctrl + c (Kill Signal) / ctrl + d (End Of File Signal)
    - 파일명 앞에 .(점) 이 있다면 hidden file
    - bash shell 명령어는 popd, cd ...  help로 detail확인 / user명령어는 which로 확인가능
        - 이는 소프트웨어에서 가상으로 돌고 있는 느낌 (user명령어 위치가 가상으로 생성됨)
    - &로 stderr도 활용가능
    - chmod
        - rwxrwxr-x : 읽기권한, 쓰기권한, 실행권한 / rwx(user)rws(group)r-x(other)
        - 디렉토리에 x가 있다면 cd 가능
        - chmod 700 {dir} : 8진수 3등분하여 계산하므로 user에만 모두 허용, 나머지 허용x
    - redirection
        - stdinput stdoutput, stderr의 방향을 변경
        - 0< 1> 2>
            - 0과 1은 생략가능
        - ex) history > {파일}
            - cat {파일} 이전 명령들을 확인가능
        - '>>' : 누적시킨다

    - pipe
        - 파이프의 왼쪽 명령어 stdoutput이 오른쪽 명령어 stdinput
        - |& : 에러 메시지를 파이프라인에 반드시 넣어줌

    - link
        - ln {가리키는 파일명} {가리킬 파일명}
        - 둘 중에 하나를 바꾸면 나머지 하나가 변경
        - inode가 같음
        - ln -s {가리키는 파일} {가리킬 파일명} : symbolic link / 쓰는 이유 - 파일크기 줄어 듦
        - 가리키는 파일을 지워도 연결되어 있는 파일들이 하나라도 살아있다면 존재
        - link와 symbolic link의 차이 중요

    - 변수
        - ex) MYNAME = "Hyeonseok shin"
            - echo $MYNAME => Hyeonseok shin 출력

    - ./a.out 1000입력-> echo $? -> 256을 나눈 나머지 252가 출력

    |명령어|설명|
    |------|---|
    |~|Home|
    |pwd|현재경로|
    |ls |-al / -ld {dir} / -al {dir}|
    |tty|terminal|
    |hostname|서비스를 제공하는 컴퓨터 확인|
    |uname|리눅스 이름|
    |wget|httpd service 이용하기 위한 client application|
    |ssh|sshd service 이용하기 위한 client application|
    | 파이프 |pipeline |
    |history|지금까지의 명령어 기록|
    |!|이전에 한 가장 최근 명령|
    |;| 명령어 연결 - 성공여부와 상관없이 다음 명령어 실행|
    |&| 백그라운드로 동작|
    |&&| 성공한 경우에 다음 명령어 실행|
    |source| 실행|
    |cc, gcc| c언어 컴파일 |
    |./*.out| 현재 디렉토리의 *.out 파일 실행|
    |which | which뒤 명령어의 위치확인|
    |more / cat| 파일 내용 확인|
    |pushd| 현재 디렉토리 푸쉬|
    |popd| 저장한 디렉토리로 다시 이동|
    |touch| 파일 만듦|
    |!$| 직전 명령어의 가장 오른쪽 명령|
    |$?| 마지막에 실행한 명령어 return값 - 성공하면 0|
    |cp {경로 및 파일} .| 경로 및 파일을 현재 디렉토리에 복사|
    |file *|모든 파일 표시|
    |wc| word count|
    |mv| 파일이동 |
    |du (-h)| 디렉토리, 파일 용량 확인|
    |set -C|파일 덮어쓰기 금지|


- Shell Script
    - '#' - comment
    - 명령어를 스크립트 형태로 저장하여 유용하게 사용 (작업시간 감소, 실수 사전 예방)
    - 실제 리눅스에서 사용
    - 확장자 {이름.sh}
    - script 실행시 1. {source 이름.sh} | 2. chmod 774 이후 a.out 파일 실행 | 3. bash ./{파일명}
    - for i in testfile_7?.c ; do echo $! ${i%.c}.cpp ;done (중간)  
    - ls > ls.txt ; ls | wc 의 맨 첫 number는? ls 줄 + 1 (ls.txt가 미리 실행되기 때문 ) (중간)