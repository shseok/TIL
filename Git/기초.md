# Git

- 파일의 변경사항을 추적하기 위해 쓰임
- 형상관리를 위해 만들어짐
- 유닉스 계열은 모두 파일로 구성되어 있어서 vi ~/.gitconfig 로 기본 설정을 볼 수 있다.

- --global을 붙여주면 .git에 config파일이 수정됨
- git status를 할 때 현재 디렉토리에서 .git을 찾고 없으면 윗 디렉토리에서 발견할 때(home디렉토리까지)까지 찾는다.
- gitlab에서 소스관리(git) ,이슈 관리, 위키, 코드품질리뷰, 변경이력관리, 릴리즈관리, CI/CD 모두 제공.
- 중간
- .gitignore에 파일이 크고 자주 바뀌는 것을 넣어놓으면 안된다.
- directory에 어떠한 파일도 존재하지 않을경우 commit이 안된다.
- Repository : project의 revision, history를 유지 관리하기 위한 모든 정보를 보관
    - commit 단위로 저장
    - commit -> 보관할 가치가 있는 한 단위
    - repository로 저장 (local)
- Object storage
    - tree
    - Blob
    - tag
- git commit -a -m "{message}"
    - add와 commit을 동시에
- git diff
    - add이전(not staged) 변경된 사항 확인
- git diff --staged
    - add이후(staged but not commit) 변경된 사항 확인
- staged 상태에서 unstaged 상태로
    - git reset HEAD {file}
    - --hard는 왠만하면 쓰지않는게 좋다
- unstaged 상태에서 working directory에 있는 것을 이전으로 되돌라고 싶을 때
    - git checkout -- {file}
- git log branchB...branchA
- git diff branchB...branchA
- git show [SHA]
- git reset --hard [SHA]
- git stash
    - staged상태의 것들이 stack에 쌓임
    - 보통 수정하고 보관하고 싶은게 있을때 사용
        - 작업을 변경하고 있는 중 상사가 작업 변경 전의 파일을 보내달라고 할 때 git stash 하면 기존 변경된 작업을 stack에 쌓고 변경 이전 상태로 
            
    - 그럼 commit 되기 이전 상태까지 모두 stash에 넣는건가?? 
    - 근데 왜 stack 구조와 반대로 쌓이지??
    - git stash list
    - git stash show
        - git stash show [num]
    - git stash drop [num]

- git push
    - push뒤에 아무것도 안쓰면 전체 브랜치를 원격에 보냄
- branch
    - main에서 수정하고 unstaged 상태로 다른 브랜치로 이동하면 수정한 파일을 볼 수 있다. (untracked 때문)
    - main에서 수정한 파일을 staged 상태로 변경 후 다른 브랜치로 이동하면 수정한 파일을 볼 수 없다. (갱신)
- merge
    - merge 이후 commit

- Your branch is ahead of 'origin/main' by 1 commit.
    - 가장 최근에 push이후 commit 안한게 있다.
    - git log 했을 때 HEAD가 origin/main보다 1개 앞에 있을 것임


## Ref
- [GIT CHEAT SHEET](https://education.github.com/git-cheat-sheet-education.pdf)
- [GIT KR](https://git-scm.com/book/ko/v2)
