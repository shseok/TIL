# Git

- 파일의 변경사항을 추적하기 위해 쓰임
- 형상관리를 위해 만들어짐
- 유닉스 계열은 모두 파일로 구성되어 있어서 vi ~/.gitconfig 로 기본 설정을 볼 수 있다.

- --global을 붙여주면 .git에 config파일이 수정됨
- git status를 할 때 현재 디렉토리에서 .git을 찾고 없으면 윗 디렉토리에서 발견할 때(home디렉토리까지)까지 찾는다.
- gitlab에서 소스관리(git) ,이슈 관리, 위키, 코드품질리뷰, 변경이력관리, 릴리즈관리, CI/CD 모두 제공.
- 중간
- .gitignore에 파일이 크고 자주 바뀌는 것을 넣어놓으면 안된다.
- directory에 어떠한 파일도 존재하지 않을경우 commit이 안된다.
- Repository : project의 revision, history를 유지 관리하기 위한 모든 정보를 보관
    - commit 단위로 저장
    - commit -> 보관할 가치가 있는 한 단위
    - repository로 저장 (local)
- Object storage
    - tree
    - Blob
    - tag
- git commit -a -m "{message}"
    - add와 commit을 동시에
- git diff
    - add이전(not staged) 변경된 사항 확인
- git diff --staged
    - add이후(staged but not commit) 변경된 사항 확인
- staged 상태에서 unstaged 상태로
    - git reset HEAD {file}
    - --hard는 왠만하면 쓰지않는게 좋다
        - hard를 마지막에 쓰면 모든 파일이 reset된 commit 상태로 돌아감
- unstaged 상태에서 working directory에 있는 것을 이전으로 되돌라고 싶을 때
    - git checkout -- {file}
- git log branchB...branchA
- git diff branchB...branchA
- git show [SHA]
- git reset --hard [SHA]
- git stash
    - staged상태의 것들이 stack에 쌓임
    - 보통 수정하고 보관하고 싶은게 있을때 사용
        - 작업을 변경하고 있는 중 상사가 작업 변경 전의 파일을 보내달라고 할 때 git stash 하면 기존 변경된 작업을 stack에 쌓고 변경 이전 상태로 
            
    - 그럼 commit 되기 이전 상태까지 모두 stash에 넣는건가?? 
    - 근데 왜 stack 구조와 반대로 쌓이지??
    - git stash list
    - git stash show
        - git stash show [num]
    - git stash drop [num]

- git push
    - push뒤에 아무것도 안쓰면 전체 브랜치를 원격에 보냄
- branch
    - main에서 수정하고 unstaged 상태로 다른 브랜치로 이동하면 수정한 파일을 볼 수 있다. (untracked 때문)
    - main에서 수정한 파일을 staged 상태로 변경 후 다른 브랜치로 이동하면 수정한 파일을 볼 수 없다. (갱신)
- merge
    - merge 이후 commit

- Your branch is ahead of 'origin/main' by 1 commit.
    - 가장 최근에 push이후 commit 안한게 있다.
    - git log 했을 때 HEAD가 origin/main보다 1개 앞에 있을 것임

- 완료한 commit을 취소해야 할 때가 있다. | 너무 일찍 commit한 경우 | 어떤 파일을 빼먹고 commit한 경우 이때, ``git reset HEAD^`` 명령어를 통해 git commit을 취소할 수 있다.

- git checkout -b {브랜치명}
    - 새로운 브랜치 생성 후 이동

- git remote
    - 삭제 : git remote rm {삭제할 remote명}
    - 이름변경 : git remote rename {변경할 remote명} {변경될 remote명}


### Merge pull reques
~한 일이 일어났다는 사실을 알 수 있음 (지저분할 수 있다)
### Squash and merge
보기 좋게 조작
- 브랜치의 하나의 버젼을 마스터에 병합
### Rebase and merge
보기 좋게 조작
- 한줄로 마스터에 브랜치 병합
### [merge와 rebase 차이](https://backlog.com/git-tutorial/kr/stepup/stepup1_4.html)

## fast-foward
Merge한 커밋을 남기지 않고 병합 가능하다.
- merge한 시점의 기록은 안보임
- fast-forward vs non fast-forward
    - <img src="./img/fast-forward.png" width="600px" height="200px" alt=""/> 
- [자세히](https://backlog.com/git-tutorial/kr/stepup/stepup1_4.html)
### 병합종류
1. 보통의 병합 (--ff)
2. 이기적 병합 (--no-ff)
3. 소심한 병합 (--ff-only)
4. 양아치 병합 (--squash)

### fetch
원격 저장소의 데이터를 로컬에 가져오기만 하기
- 즉, 단순히 원격 저장소의 내용을 확인만 하고 로컬 데이터와 병합은 하고 싶지 않은 경우
- [자세히](https://backlog.com/git-tutorial/kr/stepup/stepup3_2.html)
- github에 master branch에 있는 것을 main branch로 합치는 상황(여기서는 master가 기타 branch 역할)
    - 새로운 directory 생성 -> git fetch origin
    - <img src="./img/fetch.png" width="420px" height="140px" alt=""/> 

        - 원격에서 데이터를 가져오고 origin/master 포인터의 위치를 최신 커밋으로 이동시킨다. [노트 밑 내용 참고](https://git-scm.com/book/ko/v2/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%A6%AC%EB%AA%A8%ED%8A%B8-%EB%B8%8C%EB%9E%9C%EC%B9%98)
    - <img src="./img/checkout.png" width="420px" height="62px" alt=""/> 

        - 원격의 master브랜치를 새 master 브랜치로 만들고 만든 브랜치로 이동한다.
        - origin/master 에서 시작하고 수정할 수 있는 master라는 로컬 브랜치가 만들어진다.

## gitignore
[버전관리 수행중이 파일 작성시 방법](https://kyu9341.github.io/Git/2020/08/23/git_gitignore/)

## Ref
- [GIT CHEAT SHEET](https://education.github.com/git-cheat-sheet-education.pdf)
- [GIT KR](https://git-scm.com/book/ko/v2)
